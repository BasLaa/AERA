; test model: "hand holds cup -> (hand at position p -> cup at position p)"
;
; 1 - construction:
; build an abstraction group (abst_grp: contains abstraction programs (abst_pgmx)).
; build three r-groups (r_grpx) made visible from abst_grp.
; populate each r-group, i.e. inject objects in the r-groups: they are abstracted by the ipgm in abst_grp (see i_abst_pgm1).
; after 90ms, the model is built and projected onto stdin (see assemble_model) so it gets inputs from there (like any program).
; after 100 ms (i.e. the upr of abst_grp), the r-groups are no longer projected in abst_grp, this switches abstraction off.
; WARNING
; pertaining to abstraction programs:
; a - we are currently limited to 2 levels of depth for chain pointers (ex: in.object; we cannot write things like in.x.y since in is already a member of f).
; b - the notification of chain pointers is wrong (but the calculus is correct).
;
; 2 - exploitation:
; after 120ms, inject samples in stdin: the r-groups will reduce them and produce predictions.
; N.B.: do not inject anything in r-groups after the construction phase.


; build the abstraction group and programs.

abst_grp:(std_grp 1 0 0 0 [root])
[]
   [SYNC_FRONT now 0 forever root nil COV_OFF 0]

abst_pgm1:(pgm
[]
   (ptn var1:(var ::) |[])
   (ptn var2:(var ::) |[])
[]
   []
      (ptn (fact in:(mk.val : hold ::) ::) |[])
   |[]
   |[]
[]
   (subst [in.obj var1])
   (subst [in.val var2])
1
)
|[]

i_abst_pgm1:(ipgm abst_pgm1 [nil nil] RUN_ALWAYS 0us NOTIFY 1)
[]
   [SYNC_FRONT now 0 forever abst_grp nil 1]

abst_pgm2:(pgm
[]
   (ptn var1:(var ::) |[])
   (ptn var2:(var ::) |[])
   (ptn var3:(var ::) |[])
[]
   []
      (ptn f:(fact in:(mk.val : position ::) ::) |[])
   |[]
   |[]
[]
   (subst [in.obj var1])
   (subst [in.val var2])
   (subst [f.time var3])
1
)
|[]

i_abst_pgm2:(ipgm abst_pgm2 [nil nil nil] RUN_ALWAYS 0us NOTIFY 1)
[]
   [SYNC_FRONT now 0 forever abst_grp nil 1]

; build the model: first the r-groups, then their population.

r_grp1:(std_rgrp 0 0 0 0)
[]
   [SYNC_FRONT now 0 1 abst_grp nil COV_OFF 1]; make r_grp1 visible from abst_grp to allow abstraction programs..
                                             ; reducing the content of r_grp; notice the resilience set to 1.
r_grp2:(std_rgrp 0 0 0 0)
[]
   [SYNC_FRONT now 0 forever r_grp1 nil COV_OFF 0]; project the child on its parent before anywhere else.
   [SYNC_FRONT now 0 1 abst_grp nil COV_OFF 1]

r_grp3:(std_rgrp 0 0 0 0)
[]
   [SYNC_FRONT now 0 forever r_grp2 nil COV_OFF 0]; project the child on its parent before anywhere else.
   [SYNC_FRONT now 0 1 abst_grp nil COV_OFF 1]

hand_holds_cup:(mk.val hand hold cup 1)
|[]

(fact hand_holds_cup 0us 1)
[]
   [SYNC_STATE now 1 1 r_grp1 nil]

pos:(val (vec3 0 0 0) 0.1 1)
|[]

t:(val 0us 0.1 1)
|[]

hand_pos:(mk.val hand position pos 1)
|[]

(fact hand_pos t 1)
[]
   [SYNC_STATE now 1 1 r_grp2 nil]

cup_pos:(mk.val cup position pos 1)
|[]

(fact cup_pos t 1)
[]
   [SYNC_STATE now 1 1 r_grp3 nil]

build_model:(pgm
|[]
|[]
[]
   (inj []
      fmd:(fmd r_grp1 [root] [root] 0us 1); fmd points to the head r-group.
      [SYNC_FRONT now 0 forever stdin nil 1]; put the fmd in stdin, in an active state.
   )
   (inj []
      (imd r_grp3 [root] [root] fmd 1); imd points to the tail r-group.
      [SYNC_FRONT now 0 forever stdin nil 1]; put the imd in stdin, in an active state.
   )
1)
|[]

i_build_model:(ipgm build_model |[] RUN_ONCE 90000us SILENT 1)
[]
   [SYNC_FRONT now 0 1 root nil 1]


; inject inputs in stdin to be matched by the model (will trigger the production of predictions/assumptions).

new_pos:(val (vec3 2 2 2) 0.1 1)
|[]

new_hand_pos:(mk.val hand position new_pos 1)
|[]

new_cup_pos:(mk.val cup position new_pos 1)
|[]

inject_inputs:(pgm
|[]
|[]
[]
   (inj []
      (fact hand_holds_cup now 1)
      [SYNC_FRONT now 1 1 stdin nil]
   )
   (inj []
      new_t:(val now 0.2 1)
      [SYNC_FRONT now 1 1 stdin nil]
   )
   (inj []
      (fact new_hand_pos new_t 1)
      [SYNC_FRONT now 1 1 stdin nil]
   )
   (inj []
      (fact new_cup_pos new_t 1)
      [SYNC_FRONT now 1 1 stdin nil]
   )
1)
|[]

i_inject_inputs:(ipgm inject_inputs |[] RUN_ONCE 120000us NOTIFY 1)
[]
   [SYNC_FRONT now 0 2 root nil 1]

; an assumption is produced (mk.asmp (fact (mk.val cup pos new_pos 1) new_t 1) fmd 1 1).
; it is an assumption since the predicted time is <= the time the conclusion is built.
; the validity of the assumption is checked and produces a mk.success on the assumption.