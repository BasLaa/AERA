; initial high-level patterns (HLP).
; abstraction is fully automatic: HLPs are built from examples.
; caveat: the provided examples will be patched. Do not refer to ontological entities here (however, ont are safe).


; a self hand position.

self_hand:(ent 1) |[]

self_hand_is_a_hand:(mk.val self_hand essence hand 1) |[]
f_self_hand_is_a_hand:(fact self_hand_is_a_hand 0us 1 1) |[]

self_hand_belongs_to_self:(mk.val self_hand part_of self 1) |[]
f_self_hand_belongs_to_self:(fact self_hand_belongs_to_self 0us 1 1) |[]

self_hand_pos:(mk.val self_hand position (vec3 0 0 0) 1) |[]
f_self_hand_pos:(fact self_hand_pos 0us 1 1) |[]

self_hand_position:(cst [f_self_hand_is_a_hand f_self_hand_belongs_to_self f_self_hand_pos] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; move a self hand -> update a self hand position.

 cmd_move:(cmd move_hand [self_hand (vec3 0 0 0) 100000us] 1) |[]
 f_cmd_move:(fact cmd_move 0us 1 1) |[]

 a_self_hand_pos:(icst self_hand_position [self_hand (vec3 0 0 0) 100000us] 1) |[]
 f_a_self_hand_pos:(fact a_self_hand_pos 100000us 1 1) |[]

 move_hand_:(mdl [f_cmd_move f_a_self_hand_pos] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; same position

thing_0:(ent 1) |[]
thing_1:(ent 1) |[]

thing_0_position:(mk.val thing_0 position (vec3 0 0 0) 1) |[]
f_thing_0_position:(fact thing_0_position 0us 1 1) |[]

thing_1_position:(mk.val thing_1 position (vec3 0 0 0) 1) |[]
f_thing_1_position:(fact thing_1_position 0us 1 1) |[]

same_position:(cst [f_thing_0_position f_thing_1_position] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; move

thing_2:(ent 1) |[]

thing_2_position_0:(mk.val thing_2 position (vec3 0 0 0) 1) |[]
f_thing_2_position_0:(fact thing_2_position_0 0us 1 1) |[]

thing_2_position_1:(mk.val thing_2 position (vec3 10 10 10) 1) |[]
f_thing_2_position_1:(fact thing_2_position_1 100000us 1 1) |[]

move:(cst [f_thing_2_position_0 f_thing_2_position_1] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; link

thing_3:(ent 1) |[]
thing_4:(ent 1) |[]

thing_3_move:(icst move [thing_3 (vec3 10 10 10) 100000us (vec3 0 0 0) 0us] 1) |[]
f_thing_3_move:(fact thing_3_move 100000us 1 1) |[]

thing_4_move:(icst move [thing_4 (vec3 10 10 10) 100000us (vec3 0 0 0) 0us] 1) |[]
f_thing_4_move:(fact thing_4_move 100000us 1 1) |[]

link:(cst [f_thing_3_move f_thing_4_move] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; grab

thing_5:(ent 1) |[]
self_hand_1:(ent 1) |[]

cmd_grab:(cmd grab_hand [self_hand_1 100000us] 1) |[]
f_cmd_grab:(fact cmd_grab 0us 1 1) |[]
 
a_self_hand_attached:(mk.val self_hand_1 attachment thing_5 1) |[]
f_a_self_hand_attached:(fact a_self_hand_attached 100000us 1 1) |[]

grab_hand_:(mdl [f_cmd_grab f_a_self_hand_attached] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; requirement on grab.

thing_6:(ent 1) |[]
self_hand_2:(ent 1) |[]

thing_6_same_position:(icst same_position [self_hand_2 thing_6 (vec3 0 0 0) 0us] 1) |[]
f_thing_6_same_position:(fact thing_6_same_position 0us 1 1) |[]

grab_1:(imdl grab_hand_ [self_hand_2 thing_6 100000us 0us] 1) |[]
f_grab_1:(fact grab_1 100000us 1 1) |[]

grab_hand_req:(mdl [f_thing_6_same_position f_grab_1] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; attached -> link

thing_7:(ent 1) |[]
self_hand_3:(ent 1) |[]

thing_7_attached:(mk.val self_hand_3 attachment thing_7 1) |[]
f_thing_7_attached:(fact thing_7_attached 0us 1 1) |[]

thing_7_linked:(icst link [self_hand_3 thing_7 (vec3 10 10 10) 100000us (vec3 0 0 0) 0us] 1) |[]
f_thing_7_linked:(fact thing_7_linked 100000us 1 1) |[]

attached_link:(mdl [f_thing_7_attached f_thing_7_linked] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; release

thing_8:(ent 1) |[]
self_hand_4:(ent 1) |[]

cmd_release:(cmd release_hand [self_hand_4 100000us] 1) |[]
f_cmd_release:(fact cmd_release 0us 1 1) |[]
 
a_self_hand_attached:(mk.val self_hand_4 attachment thing_8 1) |[]
af_a_self_hand_attached:(|fact a_self_hand_attached 100000us 1 1) |[]

release_hand_:(mdl [f_cmd_release af_a_self_hand_attached] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; requirement on release.

thing_9:(ent 1) |[]
self_hand_5:(ent 1) |[]

thing_9_attached:(mk.val self_hand_5 attachment thing_9 1) |[]
f_thing_9_attached:(fact thing_9_attached 0us 1 1) |[]

release_1:(imdl release_hand_ [self_hand_5 thing_9 100000us 0us] 1) |[]
f_release_1:(fact release_1 100000us 1 1) |[]

grab_hand_req:(mdl [f_thing_9_attached f_release_1] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]
