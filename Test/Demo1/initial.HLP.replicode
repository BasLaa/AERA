; initial high-level patterns (HLP).
; abstraction is fully automatic: HLPs are built from examples.
; caveat: the provided examples will be patched. Do not refer to ontological entities here (however, ont are safe).

; utilities.

self_hand:(ent 1) |[]


; a self hand position.

self_hand_is_a_hand:(mk.val self_hand essence hand 1) |[]
f_self_hand_is_a_hand:(fact self_hand_is_a_hand 0us 1 1) |[]

self_hand_belongs_to_self:(mk.val self_hand part_of self 1) |[]
f_self_hand_belongs_to_self:(fact self_hand_belongs_to_self 0us 1 1) |[]

self_hand_pos:(mk.val self_hand position (vec3 0 0 0) 1) |[]
f_self_hand_pos:(fact self_hand_pos 0us 1 1) |[]

self_hand_position:(cst [f_self_hand_is_a_hand f_self_hand_belongs_to_self f_self_hand_pos] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; move a self hand -> update a self hand position.

 cmd_move:(cmd move_hand [self_hand (vec3 0 0 0) 100000us] 1) |[]
 f_cmd_move:(fact cmd_move 0us 1 1) |[]

 a_self_hand_pos:(icst self_hand_position [self_hand (vec3 0 0 0) 100000us] 1) |[]
 f_a_self_hand_pos:(fact a_self_hand_pos 100000us 1 1) |[]

 move_hand:(mdl [f_cmd_move f_a_self_hand_pos] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; same position

thing_0:(ent 1) |[]
thing_1:(ent 1) |[]

thing_0_position:(mk.val thing_0 position (vec3 0 0 0) 1) |[]
f_thing_0_position:(fact thing_0_position 0us 1 1) |[]

thing_1_position:(mk.val thing_1 position (vec3 0 0 0) 1) |[]
f_thing_1_position:(fact thing_1_position 0us 1 1) |[]

same_position:(cst [f_thing_0_position f_thing_1_position] [stdin] 0us 1) [[SYNC_FRONT now 0 forever stdin nil 1]]


; link

; grab

; release

; reach






















