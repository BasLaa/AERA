{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10200\viewh13940\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural

\f0\fs24 \cf0 class JobEntry \{\
	virtual void process() = 0;\
	virtual void finish() = 0; // called with a locked job queue mutex\
\};\
\
class RMemJob : public JobEntry \{\
	RMemJob(memory* memory_) :memory(memory_) \{\}\
	void process() \{ memory->process(); \}\
	void finish() \{ memory->queueInputJobs(); \}\
	RMem *memory;\
\};\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 class InputJob : public JobEntry \{\
	...\
	void finish() \{\
		input->sendMessagesToPrograms();\
		if (--input->core->jobCount == 0)\
			input->core->createJob();\
	\}\
\};\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 \
class RCoreJob : public JobEntry \{\
	...\
	void finish() \{ core->queueProcessJobs(); \}\
\};\
\
\
class ProcessJob : public JobEntry \{\
	...\
	void finish() \{\
		process->sendMessagesToMemory();\
		if (--process->memory->jobCount == 0)\
			process->memory->createJob();\
	\}\
\};\
\
TODO:\
priority for core & memory jobs\
	two queues - one for regular jobs, one for priority jobs\
\
timing & outside input job creation for memory jobs\
	memory has a "schedule entry" pointer, pointing to an iterator in a multimap owned in the RSystem.  The schedule entry pointer is != map.end() iff the memory is suspended; every time a message is sent or it's wakened, the schedule entry is erased and the pointer is set to end().\
\
what to do when worker threads are starved of jobs to run\
	
\b initialize
\b0 ()\
		queueNotEmptyMutex.lock()\
	
\b add
\b0 ()\
		queueMutex.lock()\
		if (<queue is empty>)\
			queueNotEmptyMutex.release()\
		<put items into queue>\
		queueMutex.unlock()\
\
	
\b getJob
\b0 ()\
		queueMutex.lock()\
		if (!queue.empty()) \{\
			job = queue.pop_front()\
		\} else \{\
			queueMutex.release()\
			queueNotEmptyMutex.lock()\
			queueMutex.lock()\
			job = queue.pop_front()\
			if(!queue.empty())\
				queueNotEmptyMutex.release()\
		\}\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\ql\qnatural\pardirnatural
\cf0 		queueMutex.release()	\
}